react-window

见： react-window.md



https://react-window.vercel.app/#/examples/list/fixed-size

参考：
https://www.codeleading.com/article/83464600958/

### 教程

[【前端技能提升】用react-window实现省内存的呈现大量数据列表_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1G14y1L76U/?spm_id_from=333.788.recommend_more_video.2&vd_source=abb66f1f7d240b0556df3816424c3d88)



[useVirtualList - ahooks 3.0](https://ahooks.js.org/zh-CN/hooks/use-virtual-list/)

#### 不定高时

![image-20230322084522143](虚拟列表.assets/image-20230322084522143.png)



切新分支 

切master

git tag 1.0.0

git merge 新分支 --no-ff



9分28 TODO

[【前端技能提升】react-window 应用window的滚动条 虚拟列表的应用_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1XG411A7NA/?spm_id_from=333.999.0.0&vd_source=abb66f1f7d240b0556df3816424c3d88)



## 实现虚拟列表？

这种方式实现的问题比较多，主要就是在滚动时的卡顿。在单元格内容使用函数或者更复杂的渲染方式的时候，滚动流畅度还不如非虚拟化。本质原因是浏览器的滚动条在滚动的时候和js执行是互斥的，必须要模拟一个滚动条，然后再用js去调用滚动，这样就能保证在实际渲染前js已经执行好了，实际上只有渲染的事情了。

大概是用transform先将容器的滚动条挤出可视区域，然后用自己实现的滚动条去渲染到原先的位置，同时监听鼠标滚轮事件(mousewheel)，根据滚轮的状态（1，-1）来计算滚动的位置，然后直接调用js的scrollTo去滚动到对应的位置。




这种方式配合实现方式为定位的虚拟列表效果比较好，可以将具体展示的表格内容定位到容器区域，根据scroll的位置计算应该显示的数据，然后重新计算定位位置即可，可以很大程度的去复用元素。



具体的可以参考这里[![img](https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/3f843e8626a3844c624fb596dddd9674.svg)segmentfault.com](https://link.juejin.cn/?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000039808261)，然后自己去实现一下，并不是很难。表格还有很多其他功能，如何把它们整合到一起，怎么去设计好才是难点。



## react-window-infinite-loader

分次请求要加载的数据

[bvaughn/react-window-infinite-loader: InfiniteLoader component inspired by react-virtualized but for use with react-window (github.com)](https://github.com/bvaughn/react-window-infinite-loader)



[在线预览 - CodeSandbox](https://codesandbox.io/s/x70ly749rq?file=/src/App.js)

```jsx
const itemCount = 1000;

<InfiniteLoader
  isItemLoaded={isItemLoaded}
  itemCount={itemCount}
  loadMoreItems={loadMoreItems}
>
  {({ onItemsRendered, ref }) => (
    <FixedSizeList
      itemCount={itemCount}
      onItemsRendered={onItemsRendered}
      ref={ref}
      {...otherListProps}
    />
  )}
</InfiniteLoader>
```

### api

| Name               | Type                                                         | Description                                                  |      |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ---- |
| `children`         | `({ onItemsRendered: Function, ref: React$Ref }) => React$Node` | Render prop. See below for example usage.                    |      |
| `isItemLoaded`     | `(index: number) => boolean`                                 | 负责记录每一项是否加载完成的方法                             |      |
| `itemCount`        | `number`                                                     | 列表中的项目数（或预期）                                     |      |
| `loadMoreItems`    | `(startIndex: number, stopIndex: number) => Promise<void>`   | 翻页时返回promise的回调，用于请求下一页                      |      |
| `minimumBatchSize` | `?number`                                                    | Minimum number of rows to be loaded at a time; defaults to 10. This property can be used to batch requests to reduce HTTP requests. | TODO |
| `threshold`        | `?number`                                                    | Threshold at which to pre-fetch data; defaults to 15. A threshold of 15 means that data will start loading when a user scrolls within 15 rows. | TODO |

### code

```jsx
function ExampleWrapper({
 // 是否还有下一页，根据最近一次的API请求获得
  hasNextPage,
	// boolean, 用于指示是否正在加载下一页数据
  isNextPageLoading,
  // 已经加载过的items数组
  items,
  // 回调函数，负责加载下一页
  loadNextPage
}) {
  // 如果存在下一页则增加一行 显示loading
  const itemCount = hasNextPage ? items.length + 1 : items.length;
	// 加载下一页的方法，loading时为空函数
  const loadMoreItems = isNextPageLoading ? () => {} : loadNextPage;
  // 每一项是否加载完（不包含loading)，1、没有下一页时， 2、当前索引小于items长度
  const isItemLoaded = index => !hasNextPage || index < items.length;

  // 渲染每一项或loading
  const Item = ({ index, style }) => {
    let content;
    if (!isItemLoaded(index)) {
      content = "Loading...";
    } else {
      content = items[index].name;
    }

    return <div style={style}>{content}</div>;
  };

  return (
    <InfiniteLoader
      isItemLoaded={isItemLoaded}
      itemCount={itemCount}
      loadMoreItems={loadMoreItems}
    >
      {({ onItemsRendered, ref }) => (
        <FixedSizeList
          itemCount={itemCount}
          onItemsRendered={onItemsRendered}
          ref={ref}
          {...props}
        >
          {Item}
        </FixedSizeList>
      )}
    </InfiniteLoader>
  );
}
```

### Advanced usage

Some use cases require cached items to be reset. For example, after a list has been sorted, previously cached items may be invalid. You can let `InfiniteLoader` know that it needs to reload cached items by calling the `resetloadMoreItemsCache` method.

```jsx
function ExampleWrapper({
  // ...
  sortOrder,
}) {
  // We create a reference for the InfiniteLoader
  const infiniteLoaderRef = useRef(null);
  const hasMountedRef = useRef(false);

  // Each time the sort prop changed we called the method resetloadMoreItemsCache to clear the cache
  useEffect(() => {
    // We only need to reset cached items when "sortOrder" changes.
    // This effect will run on mount too; there's no need to reset in that case.
    if (hasMountedRef.current) {
      if (infiniteLoaderRef.current) {
        infiniteLoaderRef.current.resetloadMoreItemsCache();
      }
    }
    hasMountedRef.current = true;
  }, [sortOrder]);
  
  // ...

  // We passed down the ref to the InfiniteLoader component
  return (
    <InfiniteLoader
      ref={infiniteLoaderRef}
      isItemLoaded={isItemLoaded}
      itemCount={itemCount}
      loadMoreItems={loadMoreItems}
    >
      {({ onItemsRendered, ref }) => (
        // ...
      )}
    </InfiniteLoader>
  );
}
```

### 参考

[使用 react-window 虚拟化大型列表 (web.dev)](https://web.dev/virtualize-long-lists-react-window/#滚动时延迟加载)

## react-virtualized-auto-sizer

高阶组件（会自动调整列表的宽高，使其自适应当前页面的宽高）

[API文档  ](https://github.com/bvaughn/react-virtualized/blob/master/docs/AutoSizer.md)

略，没啥东西https://github.com/bvaughn/react-virtualized-auto-sizer 

```jsx
import React from 'react';
import ReactDOM from 'react-dom';
import {AutoSizer, List} from 'react-virtualized';
import 'react-virtualized/styles.css'; // only needs to be imported once

// List data as an array of strings
const list = [
  'Brian Vaughn',
  // And so on...
];

function rowRenderer({key, index, style}) {
  return (
    <div key={key} style={style}>
      {list[index]}
    </div>
  );
}

// Render your list
ReactDOM.render(
  <AutoSizer>
    {({height, width}) => (
      <List
        height={height}
        rowCount={list.length}
        rowHeight={20}
        rowRenderer={rowRenderer}
        width={width}
      />
    )}
  </AutoSizer>,
  document.getElementById('example'),
);
```

## 其它虚拟库

- [react-virtualized-checkbox](https://github.com/emilebres/react-virtualized-checkbox): Checkbox group component with virtualization for large number of options
- [react-virtualized-select](https://github.com/bvaughn/react-virtualized-select): Drop-down menu for React with windowing to support large numbers of options.
- [react-virtualized-tree](https://github.com/diogofcunha/react-virtualized-tree/): A reactive tree component that aims to render large sets of tree structured data in an elegant and performant way
- [react-infinite-calendar](https://github.com/clauderic/react-infinite-calendar): Infinite scrolling date-picker with localization, themes, keyboard support, and more

## 实际场景应用

我们列表需求 每条数据可以配置图片也可以不配置图片，也可以配置视频，视频的高度也是跟着视频比例算的，列表里面还会插入 别的数据，这种情况每一项高度极度不同一，要怎么处理



vue-virtual-scroller： 下面文章阐述了选择该库原因

[虚拟列表技术引入 - 综述 - 掘金 (juejin.cn)](https://juejin.cn/post/7067133947041447943)

